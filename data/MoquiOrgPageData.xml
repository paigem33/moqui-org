<?xml version="1.0" encoding="UTF-8"?>
<entity-facade-xml type="install">
    <moqui.resource.wiki.WikiPage wikiPageId="RunDeploy" wikiSpaceId="framework" pagePath="Run and Deploy" createdByUserId="" publishedVersionName="01"/>
    <moqui.resource.wiki.WikiPageHistory wikiPageId="RunDeploy" historySeqId="01" userId="" changeDateTime="1485028800000"/>
    <moqui.resource.DbResource resourceId="RunDeploy" parentResourceId="framework_dir" filename="Run and Deploy.cwiki" isFile="Y"/>
    <moqui.resource.DbResourceFile resourceId="RunDeploy" mimeType="text/plain" versionName="01" rootVersionName="01"><fileData><![CDATA[
h1. Running and Deployment Instructions

This document explains how to run Moqui through the executable war file, or by deploying a war file in an application server.

{toc}

h2. 1. Quick Start

The only required software for the default configuration of Moqui Framework is the Java SE JDK version 8. Unless you are using OpenJDK the Oracle Java SE downloads are generally the best option:

[http://www.oracle.com/technetwork/java/javase/downloads]

# Download and unzip a binary distribution
# Load the seed and demo data (will create H2 database and tables automatically):
#* {{$ java -jar moqui.war load}}
# Run the framework (with embedded Servlet Container, Transaction Manager, Databases):
#* {{$ java -jar moqui.war}}
# In your browser (on the same machine) go to:
#* {{http://localhost:8080/}}
# With the example component in place and demo data loaded you can login with username "john.doe" and password "moqui"

For details and other approaches read on...

h3. Really Quick Start

# Download the MoquiDemo-<version>.war file (or similar HiveMind/PopCommerce war files)
#* [https://github.com/moqui/moqui-framework/releases]
# Drop the WAR file into Java Servlet Container (Jetty, Apache Tomcat, AWS ElasticBeanstalk, etc)

h2. 2. Runtime Directory and Configuration File

Moqui Framework has two main parts to deploy:

# Executable WAR File (see below; from moqui-framework repository)
# Runtime Directory with Configuration File (from moqui-runtime repository, or your own)

However you use the executable WAR file, you must have a runtime directory and you may override default settings with a XML configuration file.

The runtime directory is the main place to put components you want to load, the root files (root screen, etc) for the web application, and configuration files. It is also where the framework will put log files, H2 database files (if you are using H2), JCR repo files, etc. You will eventually want to create your own runtime directory and keep it in your own source repository (fork the moqui-runtime repository) but you can use the default one to get started.

Specify these two properties:

| {{moqui.runtime}} | Runtime directory (defaults to "./runtime") |
| {{moqui.conf}} | Conf XML file (URL or path relative to moqui.runtime) |

There are two ways to specify these two properties:

# {{MoquiInit.properties}} file on the classpath
# System properties specified on the command line (with java -D arguments)

See below for examples.


h2. 3. Executable WAR File

Yep, that's right: an executable WAR file. There are 3 main things you can
do with this (with example commands to demonstrate, modify as needed):

| Load Data:                 | {{$ java -jar moqui.war load}} |
| Run embedded web server:   | {{$ java -jar moqui.war}} |
| Deploy as WAR, for Tomcat: | {{$ cp moqui.war ../tomcat/webapps/ROOT.war}} |

You can also display settings and help information with:

{code}java -jar moqui.war -help{code}

For information about loading only certain files instead of all data files in all components, run that to see the help text.



h2. 4. Examples and Common Approaches

h3. Easy Way - Default Settings

The easiest way to run is to have a moqui directory with the moqui.war file and the runtime directory in it. With the binary distribution of Moqui when you unzip the archive this is what you'll have.

To use the default settings:

* moqui.runtime = runtime
* moqui.conf = conf/MoquiDevConf.xml (relative to runtime)

Run these commands:

| Load Data  | {{$ java -jar moqui.war load}} |
| Run Server | {{$ java -jar moqui.war}} |

h3. Common Alternate - Specify a Configuration File on Command Line

| Load Data  | {{$ java -jar moqui.war load conf=conf/MoquiProductionConf.xml}} |
| Run Server | {{$ java -jar moqui.war conf=conf/MoquiProductionConf.xml}} |

h3. Create a Custom WAR File with Settings Inside

# Add components and other resources as needed to the runtime directory
# Change ${moqui.home}/MoquiInit.properties with desired settings
# Change Moqui conf file (runtime/conf/Moqui*Conf.xml) as needed
# Create a derived WAR file based on the moqui.war file and with your runtime directory contents and MoquiInit.properties file with: {{"./gradlew addRuntime"}} or {{"ant add-runtime"}}
# Copy the created WAR file (moqui-plus-runtime.war) to deployment target
# Run server (or restart to deploy live WAR)


h2. 5. Component Management

The best way to manage source repositories for components is to have one repository (on GitHub or elsewhere) per component that contains only the component directory.

Following this pattern the Gradle build scripts in Moqui have tasks to download components and their dependencies from a git repository, or from current or release archives.

Known open source components are already configured in the {{addons.xml}} file. To add private and other components or override settings for components in the addons.xml file, create a file called {{myaddons.xml}} and put it in the moqui directory.

Here is a summary of the Gradle tasks for component management (using the HiveMind component for example). All of the get tasks get the specified component plus all components it depends on (as specified in its component.xml file).

| Get runtime directory | {{$ ./gradlew getRuntime -PlocationType=(git,current,release)}} | Called automatically if runtime directory does not exist. Location type defaults to git if .git directory exists, otherwise to current. |
| Get component | {{$ ./gradlew getComponent -Pcomponent=HiveMind -PlocationType=(git,current,release)}} | Location type defaults to git if .git directory exists, otherwise to current |
| Get from Git repository | {{$ ./gradlew getGit -Pcomponent=HiveMind}} | |
| Get current archive | {{$ ./gradlew getCurrent -Pcomponent=HiveMind}} | |
| Get release archive | {{$ ./gradlew getRelease -Pcomponent=HiveMind}} | |
| Get dependencies for all components | {{$ ./gradlew getDepends -PlocationType=(git,current,release)}} | Location type defaults to git if .git directory exists, otherwise to current |

There are also Gradle tasks to help you manage your components from git. Each of these commands does git operations if a .git directory exists for the moqui (root) repository, the runtime repository, and all components.

| Git pull all | {{$ ./gradlew gitPullAll}} |
| Git status on all | {{$ ./gradlew gitStatusAll}} |
| Git pull upstream on all | {{$ ./gradlew gitUpstreamAll}} |
| Clean all, pull all, load data | {{$ ./gradlew cleanPullLoad}} |
| Clean all, pull all, load data, all tests | {{$ ./gradlew cleanPullTest}} |
| Clean all, pull all, load data, only component tests | {{$ ./gradlew cleanPullCompTest}} |


h2. 6. Build and Run From Source

Moqui Framework uses Gradle for building from source. There are various custom tasks to automate frequent things, but most work is done with the built-in tasks from Gradle.

There is also an Ant build file for a few common tasks, but not for building from source.

| Get Component and Dependencies (for example: HiveMind) | {{$ ./gradlew getComponent -Pcomponent=HiveMind}} |  |
| Build JAR, WAR      | {{$ ./gradlew build}} |  |
| Load All Data       | {{$ ./gradlew load}}  | {{$ ant load}} |
| Run Embedded Server | {{$ ./gradlew run}}   | {{$ ant run}} |
| Create WAR with embedded runtime | {{$ ./gradlew addRuntime}}  | {{$ ant add-runtime}} |
| Clean up JARs, WAR  | {{$ ./gradlew clean}} |  |
| Clean up ALL built and runtime files (logs, dbs, etc) | {{$ ./gradlew cleanAll}} |  |

The examples above use the Gradle Wrapper (gradlew) included with Moqui. You can also install Gradle (2.0 or later) The load and run tasks depend on the build task, so the easiest to get a new development system running with a populated database is:

| Linux/Mac Gradle Wrapper | {{$ ./gradlew load run}} |
| Windows Gradle Wrapper | {{> gradlew.bat load run}} |
| Installed Gradle | {{$ gradle load run}} |

This will build the war file, run the data loader, then run the server. To stop it just press <ctrl-c> (or your preferred alternative).

h2. 7. Database Configuration

h3. Environment Variables

Support for single database configuration was added for easier Docker, etc deployment and can be used in any environment. This is an alternative to adding database configuration in the runtime Moqui Conf XML file as described in the next section.

Each of these can be system environment variables (with underscores) or Java properties (with underscores or dots) using the -D command-line argument.

The JDBC driver for the desired database must be on the classpath. The jar file can be added to the runtime/lib directory (within the moqui-plus-runtime.war file if used) or on the command line. In Docker images the runtime/lib directory within the container can be mapped to a directory on the host for convenience (along with runtime/conf and many other directories).

Note that the 'mysql' database configuration also works with MariaDB and Percona.

|| Env Var or Property || MySQL Example || Description ||
| entity_ds_db_conf | mysql | Database configuration from MoquiDefaultConf.xml or one you add |
| entity_ds_host | localhost | Host name of database server |
| entity_ds_port | 3306 | Port the database is running on |
| entity_ds_database | moqui | Name of the database on the server |
| entity_ds_schema |  | Schema within the database to use (note: leave empty by default for MySQL) |
| entity_ds_user | moqui | Database user |
| entity_ds_password | CHANGEME | Password for database user |
| entity_ds_crypt_pass | CHANGEME | The key used for encrypted fields, should be protected just like a password |

Environment variables are a convenient way to configure the database when using pre-built WAR files with runtime included or Docker images.

Another set of common environment variables to use is for URL writing:

|| Env Var or Property || Example || Description ||
| webapp_http_host | moqui.org | The hostname to use, defaults to host name or IP address used for the request |
| webapp_http_port | 80 | The port for insecure URLs |
| webapp_https_port | 443 | The port for secure URLs |
| webapp_https_enabled | true | Set to true to enable secure URLs. Defaults to false with all URLs generated for insecure port. |


h3. Moqui Conf XML File

Database (or datasource) setup is done in the Moqui Conf XML file with {{moqui-conf.entity-facade.datasource}} elements. There is one element for each entity group and the {{datasource.@group-name}} attribute matches against {{entity.@group-name}} attribute in entity definitions. By default in Moqui there are 4 entity groups: {{transactional, nontransactional, configuration, and analytical}}. If you only configure a {{datasource}} for the {{transactional}} group it will also be used for the other groups.

Here is the default configuration for the H2 database:

{code:brush: xml;}
<datasource group-name="transactional" database-conf-name="h2" schema-name=""
        start-server-args="-tcpPort 9092 -ifExists -baseDir ${moqui.runtime}/db/h2">
    <!-- with this setup you can connect remotely using "jdbc:h2:tcp://localhost:9092/MoquiDEFAULT" -->
    <inline-jdbc pool-minsize="5" pool-maxsize="50">
        <xa-properties url="jdbc:h2:${moqui.runtime}/db/h2/MoquiDEFAULT" user="sa" password="sa"/>
    </inline-jdbc>
</datasource>
{code}

The database-conf-name attribute points to a database configuration and matches against a {{database-list.database.@name}} attribute to identify which. Database configurations specify things like SQL types to use, SQL syntax options, and JDBC driver details.

This example uses a xa-properties element to use the XA (transaction aware) interfaces in the JDBC driver. The attribute on the element are specific to each JDBC driver. Some examples for reference are included in the MoquiDefaultConf.xml file, but for a full list of options look at the documentation for the JDBC driver.

The JDBC driver must be in the Java classpath. The easiest way get it there, regardless of deployment approach, is to put it in the {{runtime/lib}} directory.

Here is an example of a XA configuration for MySQL:

{code:brush: xml;}
<datasource group-name="transactional" database-conf-name="mysql" schema-name="">
    <inline-jdbc pool-minsize="5" pool-maxsize="50">
        <xa-properties user="moqui" password="CHANGEME" pinGlobalTxToPhysicalConnection="true"
                serverName="127.0.0.1" port="3306" databaseName="moqui" autoReconnectForPools="true"
                useUnicode="true" encoding="UTF-8"/>
    </inline-jdbc>
</datasource>
{code}

To use something like this put the {{datasource}} element under the {{entity-facade}} element in the runtime Moqui Conf XML file (like the {{MoquiProductionConf.xml}} file).

For more examples and details about recommended configuration for different databases see the comments in the MoquiDefaultConf.xml file:

[https://github.com/moqui/moqui-framework/blob/master/framework/src/main/resources/MoquiDefaultConf.xml]

h2. 8. Project Directory Structure

{code}- moqui (from https://github.com/moqui/moqui)
  - framework
    - build          : Results of framework build go here (classes, jars, etc)
    - data           : Seed data
    - entity         : Framework entity definitions
    - lib            : Libraries (JAR files) used in Moqui
    - screen         : Framework screens
    - service        : Framework services
    - src            : Java API, standard entities, services, data, XSDs, etc
      - api          : Java source for the Moqui Framework API
      - main         : Main implement source
        - groovy     : Groovy source (bulk of the implementation)
        - java       : Java source (a few special classes)
        - resources  : Classpath resources, placed in JAR as-is
        - webapp     : Base webapp, mostly just a WEB-INF/web.xml file
      - start        : Java source for MoquiStart, used for executable WAR
    - template       : Framework templates (screen/form, xml-actions FTLs)
    - xsd            : Framework XML Schema files
  - runtime
    - base-component : Base/framework components to deploy
      - tools        : System administration and maintenance tools
      - webroot      : Root Screen and supporting content
    - classes        : Resources to add to the runtime classpath
    - component      : Application/etc components to deploy
    - conf           : Configuration files separated by dev, staging, prod, etc
    - db             : Database files for H2, Derby, OrientDB, etc will go here
    - lib            : JAR files to add to the runtime classpath
    - log            : Log files will go here
    - template       : General Templates
    - tmp            : Temporary files
    - txlog          : Transaction log files will go here (Atomikos or Bitronix files)
{code}

The main place to put your components is in the runtime/component directory. When you use the Gradle get component tasks this is where they will go.

Components with declared dependencies (in a component.xml file in the component directory) will be loaded after the component(s) they depend on.
    ]]></fileData><histories versionName="01" versionDate="1485028800000" isDiff="N"/></moqui.resource.DbResourceFile>

    <moqui.resource.wiki.WikiPage wikiPageId="QuickTutorial" wikiSpaceId="framework" pagePath="Quick Tutorial" createdByUserId="" publishedVersionName="01"/>
    <moqui.resource.wiki.WikiPageHistory wikiPageId="QuickTutorial" historySeqId="01" userId="" changeDateTime="1485028800000"/>
    <moqui.resource.DbResource resourceId="QuickTutorial" parentResourceId="framework_dir" filename="Quick Tutorial.cwiki" isFile="Y"/>
    <moqui.resource.DbResourceFile resourceId="QuickTutorial" mimeType="text/plain" versionName="01" rootVersionName="01"><fileData><![CDATA[
h1. Moqui Framework Quick Tutorial

This tutorial is a step-by-step guide to creating and running your own Moqui component with a user interface, logic, and database interaction.

{toc}

h2. Overview

*Part 1*: To get started you'll be creating your own component and a simple "Hello world!" screen.

*Part 2*: Continuing from there you'll define your own entity (database table) and add forms to your screen to find and create records for that entity.

*Part 3*: To finish off the fun you will create some custom logic instead of using the default CrUD logic performed by the framework based on the entity definition.

The running approach used in this document is a simple one using the embedded servlet container. For more complete coverage of running and deployment options, and of the general directory structure of Moqui Framework, please read the [Run and Deploy|http://www.moqui.org/docs/framework/Run+and+Deploy] document.

The tutorial code is available here: [http://www.moqui.org/tutorial.zip]

h2. Part 1

h3. Download Moqui Framework

If you haven't already downloaded Moqui Framework, do that now.

Run Moqui using the [Running and Deployment Instructions|http://www.moqui.org/docs/framework/Run+and+Deploy].

In your browser go to {{http://localhost:8080/}}, log in as John Doe, and look around a bit.

Now quit (<ctrl>-c in the command line) and you're ready to go...

h3. Create a Component

Moqui follows the "convention over code" principle for components, so all you really have to do to create a Moqui component is create a directory:

{{$ cd runtime/component}}
{{$ mkdir tutorial}}

Now go into the directory and create some of the standard directories that you'll use later in this tutorial:

{{$ cd tutorial}}
{{$ mkdir data}}
{{$ mkdir entity}}
{{$ mkdir screen}}
{{$ mkdir script}}
{{$ mkdir service}}

With you component in place just start up Moqui (with {{$ ant run}} or the like).

h3. Add a Screen

Using your favorite IDE or text editor add a screen XML file in:

{{runtime/component/tutorial/screen/tutorial.xml}}

For now let this be a super simple screen with just a "Hello world!" label in it. The contents should look something like:

{code:brush: xml;}
<?xml version="1.0" encoding="UTF-8"?>
<screen require-authentication="false">
    <widgets>
        <label type="h1" text="Hello world!"/>
    </widgets>
</screen>
{code}

h3. Mount as a Subscreen

To make your screen available it needs to be added as a subscreen to a screen that is already under the root screen somewhere. In Moqui screens the URL path to the screen and the menu structure are both driven by the subscreen hierarchy, so this will setup the URL for the screen and add a menu tab for it.

For the purposes of this tutorial we'll use the existing root screen and header/footer/etc that are in the included runtime directory. This runtime directory has a {{webroot}} component with the root screen at:

{{runtime/component/webroot/screen/webroot.xml}}

On a side note, the root screen is specified in the Moqui Conf XML file using the {{webapp-list.webapp.root-screen}} element, and you can have multiple elements to have different root screens for different host names.

To make the subscreen hierarchy more flexible this root screen only has a basic HTML head and body, with no header and footer content, so let's put our screen under the "apps" screen which adds a header menu and will give our screen some context. Modify the {{apps}} screen by changing:

{{runtime/component/webroot/screen/webroot/apps.xml}}

Add a {{subscreens-item}} element under the {{subscreens}} element in the *apps.xml* file like:

{code:brush: xml;}
        <subscreens-item name="tutorial" menu-title="Tutorial"
                         location="component://tutorial/screen/tutorial.xml"/>
{code}

The {{name}} attribute specifies the value for the path in the URL to the screen, so your screen is now available in your browser at:

{{http://localhost:8080/apps/tutorial}}

If you don't want to modify an existing screen file and still want to mount your screen as a subscreen of another you can do so with a record in the database that looks like this:

{code:brush: xml;}
    <SubscreensItem screenLocation="component://webroot/screen/webroot/apps.xml"
                    subscreenName="tutorial" userGroupId="ALL_USERS"
                    subscreenLocation="component://tutorial/screen/tutorial.xml"
                    menuTitle="Tutorial" menuIndex="1" menuInclude="Y"/>
{code}

h3. Try Included Content

Instead of using the label element we can get the HTML from a file that is "under" the screen.

First create a simple HTML file located at:

{{runtime/component/tutorial/screen/tutorial/hello.html}}

The HTML file can contain any HTML, and since this will be included in a screen whose parent screens take care of header/footer/etc we can keep it very simple:

{code:brush: xml;}
<h1>Hello world! (from hello.html file)</h1>
{code}

Now just explicitly include the HTML file in the {{tutorial.xml}} screen definition using the {{render-mode.text}} element:

{code:brush: xml;}
<?xml version="1.0" encoding="UTF-8"?>
<screen require-authentication="false">
    <widgets>
        <label type="h1" text="Hello world!"/>
        <render-mode>
            <text type="html" location="component://tutorial/screen/tutorial/hello.html"/>
        </render-mode>
    </widgets>
</screen>
{code}

So what is this {{render-mode}} thingy? Moqui XML Screens are meant to platform agnostic and may be rendered in various environments. Because of this we don't want anything in the screen that is specific to a certain mode of rendering the screen without making it clear that it is. Under the {{render-mode}} element you can have various sub-elements for different render modes, even for different text modes such as HTML, XML, XSL-FO, CSV, and so on so that a single screen definition can be rendered in different modes and produce output as needed for each mode.

The screen is available at the same URL, but now includes the content from the HTML file instead of having it inline as a label in the screen definition.

h3. Try Sub-Content

Another way to show the contents of the {{hello.html}} file is to treat it as screen sub-content.

To do this the {{hello.html}} file must be in a sub-directory with the same name as the screen, i.e. in a {{tutorial}} directory as a sibling of the {{tutorial.xml}} file.

Now all we have to do is:

# tell the tutorial.xml screen to include child content by setting the {{screen.@include-child-content}} attribute to {{true}}
# tell the screen where to include subscreens and child content by adding a widgets.subscreens-active element
# specify the default subscreens item as the hello.html sub-content with the subscreens.default-item attribute

With those done your screen XML file should look like:

{code:brush: xml;}
<?xml version="1.0" encoding="UTF-8"?>
<screen require-authentication="false" include-child-content="true">
    <subscreens default-item="hello.html"/>
    <widgets>
        <label type="h1" text="Hello world!"/>
        <subscreens-active/>
    </widgets>
</screen>
{code}

To see the content go to a URL that tells Moqui that you want the {{hello.html}} file that is under the {{tutorial}} screen:

{{http://localhost:8080/apps/tutorial/hello.html}}

With the default subscreens item specified you can also just go to the tutorial screen's URL:

{{http://localhost:8080/apps/tutorial}}


h2. Part 2

h3. My First Entity

An entity is a basic tabular data structure, and usually just a table in a database. An entity value is equivalent to a row in the database. Moqui does not do object-relational mapping, so all we have to do is define an entity, and then start writing code using the Entity Facade (or other higher level tools) to use it.

To create a simple entity called "Tutorial" with fields "tutorialId" and "description" create an entity XML file at:

{{runtime/component/tutorial/entity/TutorialEntities.xml}}

That contains:

{code:brush: xml;}
<?xml version="1.0" encoding="UTF-8"?>
<entities>
    <entity entity-name="Tutorial" package-name="tutorial">
        <field name="tutorialId" type="id" is-pk="true"/>
        <field name="description" type="text-long"/>
    </entity>
</entities>
{code}

If you're running Moqui in dev mode the entity definition cache clears automatically so you don't have to restart, and for production mode or if you don't want to wait (since Moqui does start very fast) you can just stop and start the JVM.

How do you create the table? Unless you turn the feature off (in the Moqui Conf XML file) the Entity Facade will create the table (it it doesn't already exist) the first time the entity is used.

h3. Add Some Data

The Entity Facade has functionality to load data from, and write data to, XML files that basically elements that match entity names and attributes that map field names.

We'll create a UI to enter data later on, and you can use the Auto Screen or Entity Data UI in the Tools application to work with records in your new entity. Data files are useful for seed data that code depends on, data for testing, and data to demonstrate how a data model should be used. So, let's try it.

Create an entity facade XML file at:

{{runtime/component/tutorial/data/TutorialData.xml}}

That contains:

{code:brush: xml;}
<?xml version="1.0" encoding="UTF-8"?>
<entity-facade-xml type="seed">
    <tutorial.Tutorial tutorialId="TestOne" description="Test one description."/>
    <tutorial.Tutorial tutorialId="TestTwo" description="Test two description."/>
</entity-facade-xml>
{code}

To load this just run {{$ ant load}} or one of the other load variations described in the [Run and Deploy|http://www.moqui.org/docs/framework/Run+and+Deploy] document.

h3. Automatic Find Form

Add the XML screen definition below as a subscreen for the {{tutorial}} screen by putting it in the file:

{{runtime/component/tutorial/screen/tutorial/FindTutorial.xml}}

{code:brush: xml;}
<?xml version="1.0" encoding="UTF-8"?>
<screen require-authentication="anonymous-all">

    <transition name="findTutorial"><default-response url="."/></transition>

    <actions>
        <entity-find entity-name="tutorial.Tutorial" list="tutorialList">
            <search-form-inputs/></entity-find>
    </actions>

    <widgets>
        <form-list name="ListTutorials" list="tutorialList" transition="findTutorial">
            <auto-fields-entity entity-name="tutorial.Tutorial" field-type="find-display"/>
        </form-list>
    </widgets>
</screen>
{code}

This screen has a few key parts:

* *{{transition}}* Think of links between screens as an ordered graph where each screen is a node and the transitions defined in each screen are how you go from that screen to another (or back to the same), and as part of that transition possibly run actions or a service.
** A single {{transition}} can have multiple responses with conditions and for errors resulting in transition to various screens as needed by your UI design.
** This particular {{transition}} very simply just refers back to the current screen.
* *{{actions.entity-find}}* There is just one action run when this screen is rendered: an {{entity-find}}.
** Normally with an {{entity-find}} element (or in the Java API an EntityFind object) you would specify conditions, fields to order by, and other details about the find to run.
** In this case we are doing a find on an entity using standard parameters from an XML Form, so we can use the {{search-form-inputs}} sub-element to handle these automatically.
** To get an idea of what the parameters should be like just view the HTML source in your browser that is generated by the XML Form.
* *{{widgets.form-list}}* This is the actual form definition, specifically for a "list" form for multiple records/rows (as opposed to a "single" form).
** The {{name}} here can be anything as long as it is unique within the XML Screen.
** Note that the {{list}} refers to the result of the {{entity-find}} in the {{actions}} block, and the {{transition}} attribute refers to the {{transition}} defined at the top of the screen.
** Since the goal was to have a form automatically defined based on an entity we use the {{auto-fields-entity}} element with the name of our Tutorial entity, and *find-display* option for the {{field-type}} attribute which creates find fields in the header and display fields for each record in the table body.

To view this screen use this URL:

{{http://localhost:8080/apps/tutorial/FindTutorial}}


h3. An Explicit Field

Instead of the default for the description field, what if you wanted to specify how it should look at what type of field it should be?

To do this just add a {{field}} element inside the {{form-list}} element, and just after the {{auto-fields-entity}} element, like this:

{code:brush: xml;}
<form-list name="ListTutorials" list="tutorialList" transition="findTutorial">
    <auto-fields-entity entity-name="tutorial.Tutorial" field-type="display"/>
    <field name="description">
        <header-field show-order-by="true"><text-find hide-options="true"/></header-field>
        <default-field><display/></default-field>
    </field>
</form-list>
{code}

Because the field {{name}} attribute is the same as a field already created by the {{auto-fields-entity}} element it will override that field. If the {{name}} was different an additional field would be created. The result of this is basically the same as what was automatically generated using the {{auto-fields-entity}} element, and this is how you would do it explicitly.

h3. Add a Create Form

Let's add a button that will pop up a Create Tutorial form, and a transition to process the input.

First add the transition to the {{FindTutorial.xml}} screen you created before, right next to the {{findTutorial}} transition:

{code:brush: xml;}
<transition name="createTutorial">
    <service-call name="create#tutorial.Tutorial"/>
    <default-response url="."/>
</transition>
{code}

This transition just calls the {{create#tutorial.Tutorial}} service, and then goes back to the current screen.

Where did the {{create#tutorial.Tutorial}} service come from? We haven't defined anything like that yet. The Moqui Service Facade supports a special kind of service for entity CrUD operations that don't need to be defined, let alone implemented. This service name consists of two parts, a verb and a noun, separated by a hash (#). As long as the verb is create, update, store, or delete and the noun is a valid entity name the Service Facade will treat it as an implicit entity-auto service and do the desired operation. It does so based on the entity definition and the parameters passed to the service call. For example, with the create verb and an entity with a single primary key field if you pass in a value for that field it will use it, otherwise it will automatically sequence a value using the entity name as the sequence key.

Next let's add the create form, in a hidden container that will expand when a button is clicked. Put this inside the {{widget}} element, just above the {{form-list}} element in the original {{FindTutorial}} screen you created before so that it appears above the list form in the screen:

{code:brush: xml;}
<container-dialog id="CreateTutorialDialog" button-text="Create Tutorial">
    <form-single name="CreateTutorial" transition="createTutorial">
        <auto-fields-entity entity-name="tutorial.Tutorial" field-type="edit"/>
        <field name="submitButton"><default-field title="Create"><submit/></default-field></field>
    </form-single>
</container-dialog>
{code}

The form definition refers to the {{transition}} you just added to the screen, and uses the {{auto-fields-entity}} element with *edit* for the {{field-type}} to generate edit fields. The last little detail is to declare a button to submit the form, and it's ready to go. Try it out and see the records appear in the list form that was part of the original screen.



h2. Part 3

h3. Custom Create Service

The {{createTutorial}} transition from our screen above used the implicit entity-auto service {{create#Tutorial}}. Let's see what it would look like to define and implement a service manually.

First lets define a service and use the automatic entity CrUD implementation:

{{runtime/component/tutorial/service/tutorial/TutorialServices.xml}}

{code:brush: xml;}
<services>
    <service verb="create" noun="Tutorial" type="entity-auto">
        <in-parameters>
            <auto-parameters include="all"/>
        </in-parameters>
        <out-parameters>
            <auto-parameters include="pk" required="true"/>
        </out-parameters>
    </service>
</services>
{code}

This will allow all fields of the Tutorial entity to be passed in, and will always return the PK field (tutorialId). Note that with the {{auto-parameters}} element we are defining the service based on the entity, and if we added fields to the entity they would be automatically represented in the service.

Now change that service definition to add an inline implementation as well. Notice that the {{service.@type}} attribute has changed, and the {{actions}} element has been added.

{code:brush: xml;}
<service verb="create" noun="Tutorial" type="inline">
    <in-parameters>
        <auto-parameters include="all"/>
    </in-parameters>
    <out-parameters>
        <auto-parameters include="pk" required="true"/>
    </out-parameters>
    <actions>
        <entity-make-value entity-name="tutorial.Tutorial" value-field="tutorial"/>
        <entity-set value-field="tutorial" include="all"/>
        <if condition="!tutorial.tutorialId">
            <entity-sequenced-id-primary value-field="tutorial"/>
        </if>
        <entity-create value-field="tutorial"/>
    </actions>
</service>
{code}

Now to call the service instead of the implicit entity-auto one just change the {{transition}} to refer to this service:

{code:brush: xml;}
<transition name="createTutorial">
    <service-call name="tutorial.TutorialServices.create#Tutorial"/>
    <default-response url="."/>
</transition>
{code}

Note that the service name for a defined service like this is like a fully qualified Java class name. It has a "package", in this case "tutorial" which is the directory (possibly multiple directories separated by dots) under the component/service directory. Then there is a dot and the equivalent of the class name, in this case "TutorialServices" which is the name of the XML file the service is in, but without the .xml extension. After that is another dot, and then the service name with the verb and noun optionally separated by a hash (#).

h3. Groovy Service

What if you want to implement the service in Groovy (or some other supported scripting language) instead of the inline XML Actions? In that case the service definition would look like this:

{code:brush: xml;}
<service verb="create" noun="Tutorial" type="script"
        location="component://tutorial/script/tutorial/createTutorial.groovy">
    <in-parameters>
        <auto-parameters include="all"/>
    </in-parameters>
    <out-parameters>
        <auto-parameters include="pk" required="true"/>
    </out-parameters>
</service>
{code}

Notice that the {{service.@type}} attribute has changed to *script*, and there is now a {{service.@location}} attribute which specifies the location of the script.

Here is what the script would look like in that location:

{code:brush: groovy;}
def tutorial = ec.entity.makeValue("tutorial.Tutorial")
tutorial.setFields(context, true, null, null)
if (!tutorial.tutorialId) tutorial.setSequencedIdPrimary()
tutorial.create()
{code}

When in Groovy, or other languages, you'll be using the Moqui Java API which is based on the ExecutionContext class which is available in the script with the variable name "ec". For more details on the API see the [API JavaDocs|http://www.moqui.org/javadoc/index.html] and specifically the doc for the [ExecutionContext|http://www.moqui.org/javadoc/org/moqui/context/ExecutionContext.html] class which has links to the other major API interface pages.



h2. What's Next?

Now that you have soiled your hands with the details of Moqui Framework, see the full documentation for the framework and a summary of Mantle Business Artifacts in the book [Making Apps with Moqui (PDF)|http://www.moqui.org/MakingAppsWithMoqui-1.0.pdf].

You may also enjoy reading through the [Framework Features|http://www.moqui.org/docs/framework/Framework+Features] document.
    ]]></fileData><histories versionName="01" versionDate="1485028800000" isDiff="N"/></moqui.resource.DbResourceFile>

    <moqui.resource.wiki.WikiPage wikiPageId="FrameworkFeatures" wikiSpaceId="framework" pagePath="Framework Features" createdByUserId="" publishedVersionName="01"/>
    <moqui.resource.wiki.WikiPageHistory wikiPageId="FrameworkFeatures" historySeqId="01" userId="" changeDateTime="1485028800000"/>
    <moqui.resource.DbResource resourceId="FrameworkFeatures" parentResourceId="framework_dir" filename="Framework Features.cwiki" isFile="Y"/>
    <moqui.resource.DbResourceFile resourceId="FrameworkFeatures" mimeType="text/plain" versionName="01" rootVersionName="01"><fileData><![CDATA[
h1. Moqui Framework Features (through 2.0.0)

Moqui Framework gives you flexible tools to quickly create functional and secure applications.

Moqui Framework helps you build applications quickly and scale complex applications to hundreds of thousands of lines of efficient, well organized code instead of millions of lines of mess. Along the way you work on only what you care about, and let the framework take care of the rest.

{toc}

h2. Big Ideas

*Comprehensive:* Moqui Framework is designed to provide comprehensive infrastructure for enterprise applications and handle common things so you can focus your efforts on the business requirements, whether it be for a multi-organizational ERP system, an interactive community web site, or even a bit of simple content with a few forms thrown into the mix.

*Automatic Functionality:* By using the tools and practices recommended for the framework you can easily build complex applications with most security and performance concerns taken care of for you.

*No Code Generation:* Moqui relies on dynamic runtime functionality to avoid the need for code generation. This keeps your development artifacts small and easy to maintain, not just easy to create.

*True 3-Tier Architecture:* Many modern frameworks have tools for database interaction and user interaction but you have to roll your own logic layer. Moqui has a strongly defined and feature rich logic layer built around service-oriented principles. This makes it easy to build a service library for internal application use, and automatically expose services externally as needed.

h2. Flexible deployment

* Tested to run in Java on Windows, OS X, Linux, etc
* Multi-instance management (separate app server in container or VM, separate databases)
* Database
** Uses embedded H2 database by default
** Comes with configuration for H2, Derby, PostgreSQL, MySQL, HSQL, Oracle, DB2, and SQL Server
** Support for other databases usually with configuration only
* Other data sources
** Plugin in NoSQL and other data sources
** OrientDB graph and document database supported OOTB (runs embedded by default)
* Application Server
** Uses embedded Bitronix BTM or Atomikos TransactionsEssentials for JTA and connection pool
** JTA factory interface to plugin other transaction managers without a full J2EE container
** Support for JTA transaction manager and XA-aware connection pool from application server through JNDI
** Executable WAR file for command-line data loading and embedded Winstone servlet container
** The same WAR file can be dropped in a servlet container like Tomcat or Jetty, or a more general app server like JBoss or Weblogic
* Custom deployment (embedded, etc)
** Use the supplied MoquiServlet, or write your own based on that example, or use something other than a servlet for non-web apps
** Everything runs from an instance of the ExecutionContextFactory, so it is easy to include in custom apps or deploy through OSGi, Spring, etc
** Specify runtime directory path and conf file location using MoquiInit.properties file or System properties (java -D arguments)
* Project Build
** Build, test, and deploy with Gradle
** Directory structure consistent with de-facto standards from Maven/Gradle/etc
** Deploy and WAR tools also in Ant build file for convenience

h2. Clustering Support

* Various interfaces to plugin distributed system tools
* Default implementation using Hazelcast (in moqui-hazelcast tool component) with single configuration for all cluster coordination made easy with secure auto-discovery and cluster joining
* Distributed Entity (database) Cache Invalidation
* Distributed background service executor
* Distributed notification topic
* Distributed cache (JCache)
* Web (Servlet) session replication

h2. Default Runtime

* Moqui is designed to have a runtime directory that is separate from the framework and that makes up your applications and add-ons
* To help you get started Moqui comes with a sample runtime directory
* Sample configurations for development, staging, and production
* Configurable "root" screen with sample HTML wrappers, login, menus, etc
* Separate screens under root screen to support undecorated subscreens and the apps decorated with with header/footer/menus/etc
* Various configuration options and examples for flexible deployment and overriding templates for screen macros, xml-actions, etc
* Easy to include the runtime directory inside the deployed war file
* Support <component>/lib and runtime/lib jar loading in a cached and extended/extensible ClassLoader

h2. Technical Features

* Uses Groovy for scripting and Freemarker for templates, plus other options and easy plugin for any you want
* Uses JTA transaction management and JDBC connection pool from JNDI, or internally managed with Atomikos TransactionsEssentials, Bitronix BTM, or plug in any other
* WebSocket support through JSR-356 API or Moqui notification framework
* Manage incoming and outgoing email
* Network push printing through CUPS print servers
* Flexible resource access from files, JCR repository, and many others
* JCR 2.0 (JSR-283) based content and artifact management for Apache JackRabbit or other JCR implementations
* Implicit internationalization and easy database-driven localization
* Cache management for framework and application resources with pluggable local or distributed javax.cache (JSR-107) implementations
* Write-through per-transaction cache available for complex services to minimize database round-trips
* Built-in profiling tools for framework artifacts including screens, services, and entities
* Multi-instance management (one container or VM and one database per instance) with automation support for Docker, MySQL, etc
* Logging using SLF4J
* Built with Gradle, plus run and deploy tools included for Gradle and Ant
* Spock and JUnit for unit and integration (service call and screen render) testing

h2. Developer Friendly API

* Execution Context with information about user and application context, and access to tools
* Execution Context Factory used to get instances of the ExecutionContext and control the life cycle of the framework
* Facades for easy access to all framework functionality
** WebFacade for access to Servlet objects, parameter maps, etc
** UserFacade for current user data, login/logout/authentication, etc
** MessageFacade for general and error message management
** L10nFacade for localization of text
** Resource Facade for access to classpath, file, JCR, etc resources, and for running scripts and rendering templates (with caching for all)
** LoggerFacade for general logging, especially for non-class code
** CacheFacade for general caching, backed by ehcache
** TransactionFacade for general JTA-type operations and tracking what is currently going on with transactions, where errors originated, etc
** ScreenFacade for rendering screens using the ScreenRender interface
** Service Facade for running local and remote services by definition
** Entity Facade for database access

h2. Security

* Comprehensive security with declarative authorization
** Settings in the database, separate from implementation artifacts
** Define run-time inheritable permissions for any artifact in the system
** Both record level and implementation artifact level security
* Protection from XSS and XSRF threats (uses JSoup HTML parser/cleaner)
* Incorporates Apache Shiro, which is now used for all authentication in Moqui, by default through the MoquiShiroRealm
* Other realms such as for LDAP or ActiveDirectory can be configured with shiro.ini
* Permission model and checking for simple/flat permissions (to be used as an alternative to artifact authz)
* Runs permission and role (UserGroup) checks through Shiro realm
* User account and flexible password constraints and management
* XML Screens can require authentication and/or encryption
* XSRF protection by requiring encryption of input in body parameters
* ESAPI web input canonicalization/filtering to protect against XSS attacks
* Artifact stack and history tracking for each ExecutionContext instance (single web request, service call, etc)
* Tracked artifacts currently include screen, transition, service, entity
* Artifact Tarpitting based on configuration in db (see example ArtifactTarpit in ExampleSecurityData.xml)
* Artifact Authorization based on configuration in db
** Persists data about authz failures (in ArtifactAuthzFailure entity)
** Support authorization checks through Shiro realm
** Disable authz on data loading; command line and assumed to be safe
** Handle direct service/entity calls through ArtifactGroupMember with pattern
** For entity-implicit service calls just look for entity authz
** Support authorization on subscreens even if no authz on parent screens, ie authz for EditExample even though not for ExampleApp or any other screens in that app
** Record-level authorization (ArtifactAuthzRecord/Cond)
** Authorization with a service (ArtifactAuthzService)

h2. Performance Monitoring

* ArtifactHit and ArtifactHitBin tracking for screen, screen-content, transition, service and entity (bin only)
* Artifact hit data includes time to run, size of output (when available), date/time of hit, visit (session) the hit was in, etc
* Skip artifact stats tracking based on a conditional expression
* Lightweight "status" screen that can be used to see if server is running
* Built-in profiling for high level artifacts
** Monitors performance of screens, transitions, services, and entities
** See a full call tree for the scope of an ExecutionContext (web request, independent service call, etc)
** See a consolidated report with counts and stats for multiple runs of each artifact in a tree by use
** See hot spots by own time, own plus child time, etc

h2. Resources

* Provides access to resources through various protocols, and extensible to add support for more
* Simple API for running scripts and rendering templates
* Caching for all resources, and for compiled scripts and templates
* Interfaces you can implement for:
** resource reference and access (ResourceReference)
** template rendering (TemplateRenderer)
** script running (ScriptRunner)
* Resource references supported OOTB include:
** Java Classpath (classpath://)
** Moqui Component (component://)
** JCR Content (content://) - JCR 2.0 (JSR-283) based content and artifact management with Apache JackRabbit
** Java URL (http, https, file, ftp, jar)
* Templates supported OOTB include:
** FreeMarker (.ftl) templates (www.freemarker.org)
** GString (.gstring) templates (groovy.codehaus.org/Groovy+Templates)
** WikiText for rendering of wiki markups including:
*** Confluence (.cwiki, .confluence)
*** MediaWiki (.mediawiki)
*** Textile (.textile)
*** TracWiki (.tracwiki)
*** TWiki (.twiki)
* Scripting languages supported OOTB include:
** Groovy script (.groovy)
** JavaScript (with Rhino) (.js)
** Moqui XML Actions (.xml)
*** Converts to Groovy code then compiles for good runtime performance
*** Embeddable in service definitions, screens, etc

h2. Localization

* Base language values used as the key for localized variation lookup in database
* Localized messages/labels and entity fields
* Automatic internationalization of literal and expanded strings in most places
* Number and date/time parsing and formatting methods

h2. Web Environment

* WebFacade for easy API access to Servlet objects, parameter maps, etc
* WebApp event actions for first-hit-in-visit, before-request, after-request, after-login, before-logout, after-startup, before-shutdown
* For convenience web.requestParameters Map is automatically added to the context when it is initialized for the web (helps reduce dependency in code on web-specific stuff, ie ec.web.requestParameter references)
* Can send Maps/Lists/etc to HTTP response as JSON string (Web Facade), example of this is in EditExample.xml
* Servlet for FOP transform to PDF, etc
* Easy mapping of path and HTTP request method to services for REST, examples of this in ExampleApp.xml

h2. User Management

* UserFacade for current user data, login/logout/authentication, etc
* User preference management for predefined (with Enumeration records) or ad-hoc keys
* UserGroup support, mostly for security, similar to the concept of security "role" (avoiding the term "role" because of its use in the Party data model)
* UserGroup (ALL_USERS) that all users are automatically members of
* In UserAccount userId is internal/sequenced and the username field is used for auth/login
* Password reset email and forgot password form
* Visitor tracking (automatic visitor ID in a cookie, separate from user)
* Visit (session) tracking

h2. Common business data structures and seed data

* Enumerations and statuses with transitions
* Units of measure with conversion, including currency
* Geographic boundaries (legal and arbitrary) and points
* Time periods

h2. Entities (Database)

* Entity Facade
** Define your entities and go, no code to write and no redundancy
** Java API or XML tags for a wide variety of queries and common operations
** Event-Condition-Action rules to do things based on data changes
** Data import and export tools, including for seed and other setup data
** Configuration data documents based on database data available as nested maps or JSON
** Automatic data feed to send data documents to services on data changes for search indexing, sending notifications, etc
** Data search built on ElasticSearch for any database, resource, or other custom data
** Support OOTB for H2, Derby, HSQL, PostgreSQL, MySQL (and Percona, MariaDB, etc), SQL Server, DB2, and Oracle
** Easy to add support for other databases, usually just through configuration
** Support for plugging in other data sources
** Built-in support for the OrientDB graph and document database
** Time-based data synchronization support between Moqui systems
* Entity Definition
** Extension of other entities
** Entity field audit-logging
** Entity field encryption
** Automatic reverse-many relationship for type one relationships coming the other way (done on-demand at run-time)
** Database-driven view entity
** view-entity: merge the view-link element into the member element (also for DynamicViewEntity, DbViewEntity, *DbView screens)
** More intelligent group by fields, ie add all fields in view-entity and DynamicViewEntity to group by list if they don't have a function; with support for this get rid of alias.@group-by attribute, not needed when done automatically
* EntityValue object with support for create, update, delete, refresh db operations, find related, various get and set options
* Primary and secondary sequenced ID generation
** Simplified sequenced ID API for both primary and secondary sequenced IDs and moved configuration to entity definition, and methods to EntityValue
** Primary sequenced ID banking for better performance when creating records with sequenced single field primary key (default bank size 50)
* Entity Find (Query)
** EntityFind object with various conditions, etc supported and results of one, list, iterator, count, updateAll, or deleteAll
** Support search-form-inputs to automatically populate an entity find from form *-find fields
** Entity Cache support
** Automatic cache clearing for one, list (using RA cache), count caches
** Support offset and limit as LIMIT/OFFSET or OFFSET/FETCH depending on configuration on the database element in the Moqui conf file
** Manual SQL find with results mapped to entity with results returned in an EntityListIterator (EntityFacade.sqlFind())
* Database meta-data maintenance
** Automatically creates tables at runtime as they are used (checks entities once per server start, if configured to do so)
** Support for adding indexes when tables added
** Automatically add columns if missing in table check
** Add foreign keys to existing tables when table created
** Can check the foreign keys of all entities with existing tables and add missing ones where both tables exist; useful to run once all desired tables have been created (through a data load, test script, etc) to round out the DB meta-data
* Comprehensive data loader from entity XML files with API and command-line access
* Entity export to XML
* Entity Master data export (master record and all dependent records)
* Entity ECA rules to trigger services on entity operations
* Data Documents
** Generates JSON (or nested Map/List) data documents based on database data
** Data document and mapping to entities configured in simple database records for ad-hoc or preconfigured use
* Data Feed
** Automatically generates documents when database records change and sends them to services
** Easy to setup data document indexing by sending to OOTB service
* Data Search
** Search Data Documents by search string and/or named fields in the document
** Based on ElasticSearch (which is based on Apache Lucene)

h2. Services

* Service Facade
** Call services synchronously, async, or scheduled
** Local async service run with java.util.concurrent.ThreadPoolExecutor
** Distributed async services run with pluggable java.util.concurrent.ExecutorService implementation
** Scheduled service jobs run with java.util.concurrent.ScheduledThreadPoolExecutor, configured with extended Cron strings
** Services can be local or remote and implemented in a variety of languages
** Flexible XML service definitions
** Validation of data type, required or not, regexp, and other constraints; validation runs on server and in client with JavaScript library
** Event-Condition-Action (ECA) rules to orchestrate high level processes, externally change or augment behavior of existing services, and much more
** Native integration with Apache Camel for flexible and powerful integration with other systems and applications
** System-to-System Message management for producing/sending and receiving/consuming
* Service Definition
** Service parameter type/subtype checking
** Service parameter conversion/parsing and validation checks
** Service parameter HTML checking and cleaning (any/safe/none) with Jsoup
** Service authentication
** Service expand auto-parameters, get parameters from implements
** Automatic (with no definition) entity-based services for create, update, delete and store (create or update)
* Service running
** Call services synchronously in thread with minimal overhead
** Call services async or scheduled (uses Quartz Scheduler)
** Support of pre-configured scheduled job exists, see: http://www.quartz-scheduler.org/docs/cookbook/JobInitPlugin.html
** Service run on commit or rollback of current tx
** Service Event-Condition-Action (ECA) rules to trigger other services before validation, auth, service run, or after service run or commit, or when the tx is actually committed or rolled back
** Service runners for Java, XML Actions, inline actions, Scripts
** Interface for adding your own service runners
* Write-through per-transaction cache available for complex services to minimize database round-trips
* Email handling
** Incoming email handling with Email ECA Rules (emeca) with the org.moqui.impl.EmailServices.pollEmailServer service, configured with the EmailServer entity
** Service (org.moqui.impl.EmailServices.sendEmailTemplate) to send email based on settings in the EmailTemplate entity
* Web Services
** REST web services with minimal configuration for internal service mapping
** Generic RESTful data interface based on entity definitions, secure with authc and authz
** JSON-RPC 2.0 incoming service handler and outgoing service runner
** XML-RPC incoming service handler and outgoing service runner (with Apache XML-RPC)
* Apache Camel endpoint for receiving messages to call Moqui services, or defining services that call into Camel
* JBoss Drools KIE Support
** Easily use Drools rules in your business logic
** Use jBPM workflows for easier control and monitoring of business processes

h2. XML Screens

* Screen Facade
** Declarative multi-platform screens, text templates, or any combination
** Generate HTML, XML, PDF (XSL-FO), CSV, Fixed-width plain text, or drive GWT or Swing screens
** Screen files and included sets of subscreens in directories with the same structure as the application
** Nested subscreens for multiple levels of tabs or other types of menus
** Data preparation logic declared with screens to make each screen modular
** Outgoing transitions point to input processing logic and conditional forwarding to other screens or external URLs
** Forms (single, list), trees, panels, and various other common widgets
* Screen Definition
** Subscreens hierarchical to any depth, URL "path info" is path to screen in hierarchy
** Screen menus automatically generated based on sub-screens
** Choose default subscreen (override by path) based on user agent or other condition (using any data available in the ec)
** Sub-screens by directory structure, XML elements, or database record
** Screens and sub-content can be located in files or in a JCR repository
** Screen sub-content (stand-alone or included in screen) including support for text and binary files and all template types supported by the Resource Facade
** Can include or inline HTML and other text content
** Standalone screens that are rendered independently of parent screens and can still be subscreens of any other screen
** Support for multiple root screens determined by host name using regexp, or in other words virtual host support
** Screen transition supports restriction by HTTP request method
** Dynamic transition name handling (support regex transition names)
** Override login path in screen (use value from deepest screen in path)
** Screen pre-actions that all run before any parent screen is rendered to allow for setting parameters in parent screens, setting up general things, etc
** Database-driven screen visual themes
** Output encoding, configurable on various screen/form elements
** Includes container-dialog widget that creates a button that when clicked on opens a dialog with the contents of the container-dialog.
* Screen Rendering
** ScreenFacade for rendering screens using the ScreenRender interface
** Templates for various render modes:
*** csv (mainly for form-list report-like output)
*** text (for email alternative message, etc)
*** xml (like CSV, but more structured and support multiple forms per screen)
*** xsl-fo (generate PDF or other FOP output types)
** URL building based on configuration
** Can specify macro template in screen def to override default in moqui-conf
** Supports URL parameters for renderMode and pageNoLimit which along with the lastStandalone parameter make it easy to reuse screens and forms meant for user interaction as definitions for CSV output
** Screen subscreen menu dynamic tabs (last level only) that loads content as a standalone screen from the server with an ajax call
** Default runtime includes jquery and jquery-ui and the smoothness and dot-luv themes (easy to add others or make your own)
** Automatic I18n (with L10nFacade) for labels and titles in screens, forms, menus
* Screen Forms
** Single forms (form-single)
*** For editing a single record (or single set of fields across records)
*** Manual field-layout support
*** Default HTML uses fieldset and label instead of a table
** List forms (form-list)
*** For editing or viewing multiple records (or multiple sets of fields across records)
*** Explicit form-list-column support
*** Pagination (with defaults in search-form-inputs)
*** multi=false support (one form per row)
*** multi=true support (one form for all rows), service call multi=true
*** Header widget rendering
*** Automatic sort order links in header
** Extend XML form definitions with database records for all users or specific groups
** Form field types for many common form widgets
** Auto-complete option for text-line field type
** Form focus-field, skip-start and skip-end supported
** Automatic form fields from entity and service definitions
*** Client JS validation based on target transition service definition (define once, run on client and server); using jquery validation (http://docs.jquery.com/Plugins/Validation); so far for required, number-integer, number-decimal, text-email, text-url, text-digits, credit-card, regexp; try out on the Edit Example screen
*** Auto create drop-downs for fields with a relationship to Enumeration using relationship.title as the enumTypeId, check to see if is valid enumTypeId before creating drop-down
*** Auto create drop-downs for fields with a type one relationship, with limit of 200 to avoid crazy drop-downs
** Localized output formatting, based on service parameter format if applicable, otherwise on format specified in form field
** Includes datetimepicker, which is the standard jquery datepicker plus the timepicker add-on, combined using some code from Apache OFBiz

h2. Tools Application

* Auto Screen
** Screens generated automatically based on the data model with a find screen and a screen for each "master" entity (an entity with dependents) with tabs for each dependent entity
** There are two main types of dependent entities: "detail" entities with additional information about the master and "join" entities that go between two master entities
** Master Entity List: use autocomplete box to select any entity or select a master entity from the list
** AutoFind Screen (find, create, delete master entity records)
** AutoEditMaster (tab to edit master entity record)
** AutoEditDetail (tab for each dependent entity (detail and join entities) with CrUD)
** Order by links in column headers by default (by default for all auto fields entity as well)
* Data Document
** A Data Document is a JSON document (or nested Maps/Lists) based on data from databases and structured as defined for the document in configuration records
** Trigger document indexing
** Export data documents
** Search data documents across various indexes, view the documents, and link to application screens for the documents
* Data View
** Choose master entity, select fields from all related entities, save as DbViewEntity and related records
** Specify functions for selected fields
** Choose column(s) to order by
** Specify search constraints
** View in webapp
** Export to CSV
* Service
** Select service and run from form based on service definition
* Entity
** Entity Data UI
*** entity list
*** find on entity with delete
*** create/update entity record
*** view entity record with related entities and links to them
** Entity Data Import from file, directory, configured file set, or web form
** Entity Data Export with entity select, dependents option, date range, filter map, sort order
** SQL Query Runner
* System Info
** Artifact Hit Bins and Summary report
** Audit Log
** Visit and Hit Info/Stats (Find Visits, Visit details with hit list)
** Cache List and Elements
** Localization: Messages, Entity Fields

h2. Example Application

* Example application with screens, sub-content (CSS, html.ftl, cwiki.ftl), entities and services, security, l10n data, etc
* Example entities and seed data follow pattern used in Moqui and Mantle where the relationship.title is the enumTypeId or the statusTypeId
    ]]></fileData><histories versionName="01" versionDate="1485028800000" isDiff="N"/></moqui.resource.DbResourceFile>
</entity-facade-xml>
